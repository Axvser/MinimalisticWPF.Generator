using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.Tracing;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MinimalisticWPF.Generator
{
    [Generator]
    public class BackendCodeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classDeclarations = AnalizeHelper.DefiningFilter(context);
            var compilationAndClasses = AnalizeHelper.GetValue(context, classDeclarations);
            context.RegisterSourceOutput(compilationAndClasses, GenerateSource);
        }
        private static void GenerateSource(SourceProductionContext context, (Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> Classes) input)
        {
            var (compilation, classes) = input;

            HashSet<INamedTypeSymbol> processedSymbols = [];                     // 类唯一性 - 语义
            HashSet<ClassDeclarationSyntax> uniqueClasses = [];                  // 类唯一性 - 语法
            Dictionary<ClassDeclarationSyntax, HashSet<string>> namespaces = []; // 合并多分部中所有的命名空间引用
            foreach (var classDeclaration in classes)
            {
                SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null)
                    continue;

                if (namespaces.TryGetValue(classDeclaration, out var hashset))
                {
                    foreach (var ns in ClassRoslyn.GetReferencedNamespaces(classSymbol))
                    {
                        hashset.Add(ns);
                    }
                }
                else
                {
                    namespaces.Add(classDeclaration, ClassRoslyn.GetReferencedNamespaces(classSymbol));
                }

                processedSymbols.Add(classSymbol);
                uniqueClasses.Add(classDeclaration);
            }

            Dictionary<Tuple<INamedTypeSymbol, ClassDeclarationSyntax>, StringBuilder> generatedSources = []; // 生成文本
            foreach (var classDeclaration in uniqueClasses)
            {
                SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null)
                    continue;

                var classRoslyn = new ClassRoslyn(classDeclaration, classSymbol);

                if (!generatedSources.TryGetValue(Tuple.Create(classSymbol, classDeclaration), out var sourceBuilder))
                {// 以下按三种情况讨论项目
                    sourceBuilder = new StringBuilder();
                    sourceBuilder.AppendLine($"// <auto-generated/>");
                    if (classRoslyn.IsContextConfig && !classRoslyn.IsViewModel)
                    {// 配置ViewModel，以依赖属性的自动生成为主
                        var vm = uniqueClasses.FirstOrDefault(x => x.Identifier.Text == classRoslyn.ViewModelTypeName
                                                                && (string.IsNullOrEmpty(classRoslyn.ViewModelValidation) || compilation.GetSemanticModel(x.SyntaxTree)?.GetDeclaredSymbol(x)?.ContainingNamespace.ToString() == classRoslyn.ViewModelValidation));
                        if (vm != null)
                        {
                            SemanticModel vmModel = compilation.GetSemanticModel(vm.SyntaxTree);
                            var vmsymbol = vmModel.GetDeclaredSymbol(vm);
                            if (vmsymbol != null)
                            {
                                if (!string.IsNullOrEmpty(classRoslyn.ViewModelValidation) && vmsymbol.ContainingNamespace.ToString() != classRoslyn.ViewModelValidation)
                                {
                                    continue;
                                }
                                sourceBuilder.AppendLine(classRoslyn.GenerateUsing(namespaces[classDeclaration]));
                                sourceBuilder.AppendLine(classRoslyn.GenerateNamespace());
                                sourceBuilder.AppendLine(classRoslyn.GeneratePartialClass());
                                sourceBuilder.AppendLine(classRoslyn.GenerateITA());
                                var vmclassRoslyn = new ClassRoslyn(vm, vmsymbol);
                                sourceBuilder.AppendLine(vmclassRoslyn.GenerateDependencyProperties(classRoslyn.Symbol.ContainingNamespace.ToString() + '.' + classRoslyn.Syntax.Identifier.Text, vmsymbol.ContainingNamespace.ToString(), classRoslyn.ViewModelTypeName));
                                sourceBuilder.AppendLine(vmclassRoslyn.GenerateHoverDependencyProperties(classRoslyn.Symbol.ContainingNamespace.ToString() + '.' + classRoslyn.Syntax.Identifier.Text, vmsymbol.ContainingNamespace.ToString(), classRoslyn.ViewModelTypeName));
                                sourceBuilder.AppendLine(classRoslyn.GenerateEnd());
                                generatedSources[Tuple.Create(classSymbol, classDeclaration)] = sourceBuilder;
                            }
                        }
                    }
                    else if (classRoslyn.IsViewModel && !classRoslyn.IsContextConfig)
                    {// 定义ViewModel，一切效果直接以C#实现
                        sourceBuilder.AppendLine(classRoslyn.GenerateUsing(namespaces[classDeclaration]));
                        sourceBuilder.AppendLine(classRoslyn.GenerateNamespace());
                        sourceBuilder.AppendLine(classRoslyn.GeneratePartialClass());
                        sourceBuilder.AppendLine(classRoslyn.GenerateConstructor());
                        sourceBuilder.AppendLine(classRoslyn.GenerateIPC());
                        sourceBuilder.AppendLine(classRoslyn.GenerateITA());
                        foreach (var fieldRoslyn in classRoslyn.FieldRoslyns)
                        {
                            sourceBuilder.AppendLine(fieldRoslyn.GenerateCode());
                        }
                        sourceBuilder.AppendLine(classRoslyn.GenerateHoverControl());
                        sourceBuilder.AppendLine(classRoslyn.GenerateEnd());
                        generatedSources[Tuple.Create(classSymbol, classDeclaration)] = sourceBuilder;
                    }
                    else
                    {// 不属于此项目分析的范畴
                        continue;
                    }
                }
            }

            foreach (var kvp in generatedSources)
            {
                context.AddSource($"{kvp.Key.Item1.ContainingNamespace.ToString().Replace('.', '_')}_{kvp.Key.Item2.Identifier.Text}_FastBackendCodeGeneration.g.cs", SourceText.From(kvp.Value.ToString(), Encoding.UTF8));
            }  // 输出生成内容
        }
    }
}
