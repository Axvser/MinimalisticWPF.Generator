using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MinimalisticWPF.Generator
{
    [Generator]
    public class AopGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations =
                context.SyntaxProvider.CreateSyntaxProvider(
                    predicate: static (node, cancellationToken) => IsPartialClass(node),
                    transform: static (context, cancellationToken) => GetClassDeclaration(context))
                .Where(static m => m != null)!;

            IncrementalValueProvider<(Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> Classes)> compilationAndClasses =
                context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses, GenerateSource);
        }

        private static bool IsPartialClass(SyntaxNode node)//筛查:分部类型
        {
            return node is ClassDeclarationSyntax classDecl && classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        }
        private static ClassDeclarationSyntax GetClassDeclaration(GeneratorSyntaxContext context)//获取:类型声明
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            return classDeclaration;
        }

        private static void GenerateSource(SourceProductionContext context, (Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> Classes) input)//类型源文件
        {
            var (compilation, classes) = input;

            Dictionary<Tuple<INamespaceSymbol, ClassDeclarationSyntax>, StringBuilder> generatedSources = [];

            GenerateAop(context, input);

            foreach (var classDeclaration in classes.Where(x=> HasAspectOrientedAttribute(x)))
            {
                SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null)
                    continue;

                // 至少有一个字段携带 [Expandable] 特性
                var expandableFields = classSymbol.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(field => field.GetAttributes().Any(attr => attr.AttributeClass?.Name == "VMProperty"));
                if (!expandableFields.Any())
                    continue;

                if (!generatedSources.TryGetValue(Tuple.Create(classSymbol.ContainingNamespace, classDeclaration), out var sourceBuilder))
                {
                    var isAop = HasAspectOrientedAttribute(classDeclaration);
                    sourceBuilder = new StringBuilder();
                    sourceBuilder.AppendLine($"// <auto-generated/>");
                    GenerateUsing(sourceBuilder);
                    GenerateNamespace(sourceBuilder, classSymbol);
                    GeneratePartialClass(sourceBuilder, classDeclaration, classSymbol, isAop);
                    GenerateProxy(sourceBuilder, classDeclaration, classSymbol, isAop);
                    generatedSources[Tuple.Create(classSymbol.ContainingNamespace, classDeclaration)] = sourceBuilder;
                }
            }
            foreach (var kvp in generatedSources)
            {
                kvp.Value.AppendLine("}");
                kvp.Value.AppendLine("}");
                context.AddSource($"{kvp.Key.Item1.Name}_{kvp.Key.Item2.Identifier.Text}_AOP.g.cs", SourceText.From(kvp.Value.ToString(), Encoding.UTF8));
            }
        }
        private static void GenerateUsing(StringBuilder sourceBuilder)//命名空间引用
        {
            sourceBuilder.AppendLine("#nullable enable");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("using MinimalisticWPF.AopInterfaces;");
            sourceBuilder.AppendLine();
        }
        private static void GenerateNamespace(StringBuilder sourceBuilder, INamedTypeSymbol classSymbol)//命名空间引用
        {
            sourceBuilder.AppendLine($"namespace {classSymbol.ContainingNamespace}");
            sourceBuilder.AppendLine("{");
        }
        private static void GeneratePartialClass(StringBuilder sourceBuilder, ClassDeclarationSyntax cs, INamedTypeSymbol classSymbol, bool isAop)//分部类型
        {
            var aop = isAop ? $"IAop{cs.Identifier.Text}In{classSymbol.ContainingNamespace}" : string.Empty;
            var source = $$"""
                           {{cs.Modifiers}} class {{cs.Identifier.Text}} : {{aop}}
                           {
                           """;
            sourceBuilder.AppendLine(source);
        }
        private static void GenerateProxy(StringBuilder sourceBuilder, ClassDeclarationSyntax cs, INamedTypeSymbol classSymbol, bool isAop)//动态代理
        {
            if (!isAop) return;
            var aop = isAop ? $"IAop{cs.Identifier.Text}In{classSymbol.ContainingNamespace}" : string.Empty;
            sourceBuilder.AppendLine($$"""
                                          public {{aop}} Proxy { get; private set; }
                                       """);
        }

        private static void GenerateAop(SourceProductionContext context, (Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> Classes) input)
        {
            foreach (var classDeclaration in input.Classes)
            {
                // 检查类是否包含 AspectOrientedAttribute 特性
                if (!HasAspectOrientedAttribute(classDeclaration))
                {
                    continue;
                }

                // 获取类所在的命名空间
                string namespaceName = GetNamespace(classDeclaration);

                // 生成接口名称
                string interfaceName = $"IAop{classDeclaration.Identifier.Text}In{namespaceName}";

                // 创建接口声明并继承自 IProxy
                var baseList = SyntaxFactory.BaseList(
                    SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
                        SyntaxFactory.SimpleBaseType(
                            SyntaxFactory.QualifiedName(
                                SyntaxFactory.ParseName("MinimalisticWPF"),
                                SyntaxFactory.IdentifierName("IProxy")))));
                var interfaceDeclaration = SyntaxFactory.InterfaceDeclaration(interfaceName)
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                    .WithBaseList(baseList);

                // 遍历类中的所有字段
                var fields = classDeclaration.Members.OfType<FieldDeclarationSyntax>();

                foreach (var field in fields)
                {
                    // 检查字段是否包含 VMPropertyAttribute 特性
                    var vmPropertyParams = field.AttributeLists.Any(al => al.Attributes.Any(att => att.Name.ToString() == "VMProperty"));
                    if (!vmPropertyParams)
                    {
                        continue;
                    }

                    // 遍历字段声明中的每个变量声明符
                    foreach (var variable in field.Declaration.Variables)
                    {
                        var propertyName = char.ToUpper(variable.Identifier.Text[1]) + variable.Identifier.Text.Substring(2);
                        TypeSyntax propertyType = field.Declaration.Type;

                        // 创建属性声明
                        var propertyDeclaration = SyntaxFactory.PropertyDeclaration(propertyType, propertyName)
                            .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                            .WithAccessorList(
                                SyntaxFactory.AccessorList(
                                    SyntaxFactory.List(new AccessorDeclarationSyntax[]
                                    {
                                        SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)),
                                        SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)),
                                    })));

                        interfaceDeclaration = interfaceDeclaration.AddMembers(propertyDeclaration);
                    }
                }

                // 遍历类中的所有公共属性
                var properties = classDeclaration.Members.OfType<PropertyDeclarationSyntax>()
                    .Where(p => p.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)));

                foreach (var property in properties)
                {
                    // 获取属性类型
                    TypeSyntax propertyType = property.Type;
                    var prop = SyntaxFactory.PropertyDeclaration(propertyType, property.Identifier)
                        .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)));

                    // 添加 getter 到接口
                    if (property.AccessorList?.Accessors.Any(a => a.Kind() == SyntaxKind.GetAccessorDeclaration) == true)
                    {
                        prop = prop.AddAccessorListAccessors(
                            SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)));
                    }

                    // 添加 setter 到接口
                    if (property.AccessorList?.Accessors.Any(a => a.Kind() == SyntaxKind.SetAccessorDeclaration) == true)
                    {
                        prop = prop.AddAccessorListAccessors(
                            SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)));
                    }

                    interfaceDeclaration = interfaceDeclaration.AddMembers(prop);
                }

                // 遍历类中的所有公共方法
                var methods = classDeclaration.Members.OfType<MethodDeclarationSyntax>()
                    .Where(m => m.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PublicKeyword)));

                foreach (var method in methods)
                {
                    // 获取方法返回类型
                    TypeSyntax returnType = method.ReturnType;

                    // 获取方法参数列表
                    ParameterListSyntax parameterList = method.ParameterList;

                    // 创建方法签名
                    var methodSignature = SyntaxFactory.MethodDeclaration(returnType, method.Identifier)
                        .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                        .WithParameterList(parameterList)
                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

                    interfaceDeclaration = interfaceDeclaration.AddMembers(methodSignature);
                }

                // 将接口添加到命名空间中
                NamespaceDeclarationSyntax namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName("MinimalisticWPF.AopInterfaces"))
                    .AddMembers(interfaceDeclaration);

                // 生成接口代码
                string generatedCode = namespaceDeclaration.NormalizeWhitespace().ToFullString();

                // 添加生成的接口代码到 SourceProductionContext 并指定编码集
                context.AddSource($"{interfaceName}.g.cs", SourceText.From(generatedCode, Encoding.UTF8));
            }
        }
        internal static bool HasAspectOrientedAttribute(ClassDeclarationSyntax classDeclaration)
        {
            // 获取类上的所有属性列表
            var attributeLists = classDeclaration.AttributeLists;

            foreach (var attributeList in attributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    if (attribute.Name.ToString() == "AspectOriented")
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
        {
            SyntaxNode current = classDeclaration;
            while (current != null && !(current is NamespaceDeclarationSyntax))
            {
                current = current.Parent;
            }

            return current is NamespaceDeclarationSyntax namespaceDeclaration
                ? namespaceDeclaration.Name.ToString()
                : "Global";
        }
    }
}
